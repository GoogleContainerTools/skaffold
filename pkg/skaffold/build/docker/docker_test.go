/*
Copyright 2020 The Skaffold Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package docker

import (
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/docker/docker/api/types/registry"
	"github.com/docker/docker/errdefs"
	"google.golang.org/protobuf/testing/protocmp"

	"github.com/GoogleContainerTools/skaffold/v2/pkg/skaffold/config"
	"github.com/GoogleContainerTools/skaffold/v2/pkg/skaffold/docker"
	sErrors "github.com/GoogleContainerTools/skaffold/v2/pkg/skaffold/errors"
	"github.com/GoogleContainerTools/skaffold/v2/pkg/skaffold/platform"
	"github.com/GoogleContainerTools/skaffold/v2/pkg/skaffold/schema/latest"
	"github.com/GoogleContainerTools/skaffold/v2/pkg/skaffold/util"
	"github.com/GoogleContainerTools/skaffold/v2/proto/v1"
	"github.com/GoogleContainerTools/skaffold/v2/testutil"
)

var metadata = `{
  "buildx.build.ref": "default/default/8tmdcf9mpy43arexbwej851qz",
  "containerimage.config.digest": "sha256:0bb1817818c840e89daa8308168ac33d0d857faed1f6810638cc26169b8d3b13",
  "containerimage.digest": "sha256:0bb1817818c840e77afa8308168ac33d0d23adaee1f6810638cc26169b8d3b13",
  "image.name": "docker.io/library/test"
}`

func TestDockerCLIBuild(t *testing.T) {
	tests := []struct {
		description      string
		localBuild       latest.LocalBuild
		cliFlags         []string // CLI flags to pass through to command.
		cfg              mockConfig
		extraEnv         []string
		imageName        string
		err              error
		expectedEnv      []string
		expectedCLIFlags []string // CLI flags expected to be autogenerated.
		expectedErr      error
		wantDockerCLI    bool
		buildx           bool // buildx detected
		daemonless       bool // no docker daemon
		expectedErrCode  proto.StatusCode
	}{
		{
			description: "docker build",
			localBuild:  latest.LocalBuild{},
			cfg:         mockConfig{runMode: config.RunModes.Dev},
			expectedEnv: []string{"KEY=VALUE"},
		},
		{
			description: "extra env",
			localBuild:  latest.LocalBuild{},
			extraEnv:    []string{"OTHER=VALUE"},
			expectedEnv: []string{"KEY=VALUE", "OTHER=VALUE"},
		},
		{
			description:      "buildkit",
			localBuild:       latest.LocalBuild{UseBuildkit: util.Ptr(true)},
			wantDockerCLI:    true,
			expectedCLIFlags: []string{"--load"},
			expectedEnv:      []string{"KEY=VALUE", "DOCKER_BUILDKIT=1"},
		},
		{
			description:      "buildkit push",
			localBuild:       latest.LocalBuild{UseBuildkit: util.Ptr(true), Push: util.Ptr(true)},
			wantDockerCLI:    true,
			expectedCLIFlags: []string{"--load"},
			expectedEnv:      []string{"KEY=VALUE", "DOCKER_BUILDKIT=1"},
		},
		{
			description:      "buildkit buildx load",
			localBuild:       latest.LocalBuild{UseBuildkit: util.Ptr(true)},
			wantDockerCLI:    true,
			buildx:           true,
			daemonless:       false,
			imageName:        "gcr.io/k8s-skaffold/example:tag",
			expectedCLIFlags: []string{"--cache-from", "gcr.io/k8s-skaffold/example:cache", "--load", "--builder", "default", "--metadata-file", "metadata.json"},
			expectedEnv:      []string{"KEY=VALUE", "DOCKER_BUILDKIT=1"},
		},
		{
			description:      "buildkit buildx push",
			localBuild:       latest.LocalBuild{UseBuildkit: util.Ptr(true), Push: util.Ptr(true)},
			wantDockerCLI:    true,
			buildx:           true,
			daemonless:       true,
			imageName:        "gcr.io/k8s-skaffold/example:tag",
			expectedCLIFlags: []string{"--cache-from", "gcr.io/k8s-skaffold/example:cache", "--cache-to", "type=registry,ref=gcr.io/k8s-skaffold/example:cache,mode=max", "--push", "--builder", "default", "--metadata-file", "metadata.json"},
			expectedEnv:      []string{"KEY=VALUE", "DOCKER_BUILDKIT=1"},
		},
		{
			description:      "cliFlags",
			cliFlags:         []string{"--platform", "linux/amd64"},
			localBuild:       latest.LocalBuild{},
			wantDockerCLI:    true,
			expectedCLIFlags: []string{"--platform", "linux/amd64"},
			expectedEnv:      []string{"KEY=VALUE"},
		},
		{
			description:      "cliFlags replace template",
			imageName:        "docker.io/library/image:tag",
			cliFlags:         []string{"--cache-to=type=registry,ref={{ .IMAGE_REPO }}/cache-image:cache"},
			localBuild:       latest.LocalBuild{},
			wantDockerCLI:    true,
			expectedCLIFlags: []string{"--cache-to=type=registry,ref=docker.io/library/cache-image:cache"},
		},
		{
			description:      "buildkit and extra env",
			localBuild:       latest.LocalBuild{UseBuildkit: util.Ptr(true)},
			wantDockerCLI:    true,
			extraEnv:         []string{"OTHER=VALUE"},
			expectedCLIFlags: []string{"--load"},
			expectedEnv:      []string{"KEY=VALUE", "OTHER=VALUE", "DOCKER_BUILDKIT=1"},
		},
		{
			description:      "env var collisions",
			localBuild:       latest.LocalBuild{UseBuildkit: util.Ptr(true)},
			wantDockerCLI:    true,
			extraEnv:         []string{"KEY=OTHER_VALUE", "DOCKER_BUILDKIT=0"},
			expectedCLIFlags: []string{"--load"},
			// DOCKER_BUILDKIT should be overridden
			expectedEnv: []string{"KEY=OTHER_VALUE", "DOCKER_BUILDKIT=1"},
		},
		{
			description: "docker build internal error",
			localBuild:  latest.LocalBuild{UseDockerCLI: true},
			err:         errdefs.Cancelled(fmt.Errorf("cancelled")),
			expectedErr: newBuildError(errdefs.Cancelled(fmt.Errorf("cancelled")), mockConfig{runMode: config.RunModes.Dev}),
		},
		{
			description:     "docker build no space left error with prune for dev",
			localBuild:      latest.LocalBuild{UseDockerCLI: true},
			cfg:             mockConfig{runMode: config.RunModes.Dev, prune: false},
			err:             errdefs.System(fmt.Errorf("no space left")),
			expectedErr:     fmt.Errorf("Docker ran out of memory. Please run 'docker system prune' to removed unused docker data or Run skaffold dev with --cleanup=true to clean up images built by skaffold"),
			expectedErrCode: proto.StatusCode_BUILD_DOCKER_NO_SPACE_ERR,
		},
		{
			description:     "docker build no space left error with prune for build",
			localBuild:      latest.LocalBuild{UseDockerCLI: true},
			cfg:             mockConfig{runMode: config.RunModes.Build, prune: false},
			err:             errdefs.System(fmt.Errorf("no space left")),
			expectedErr:     fmt.Errorf("no space left. Docker ran out of memory. Please run 'docker system prune' to removed unused docker data"),
			expectedErrCode: proto.StatusCode_BUILD_DOCKER_NO_SPACE_ERR,
		},
		{
			description:     "docker build no space left error with prune true",
			localBuild:      latest.LocalBuild{UseDockerCLI: true},
			cfg:             mockConfig{prune: true},
			err:             errdefs.System(fmt.Errorf("no space left")),
			expectedErr:     fmt.Errorf("no space left. Docker ran out of memory. Please run 'docker system prune' to removed unused docker data"),
			expectedErrCode: proto.StatusCode_BUILD_DOCKER_NO_SPACE_ERR,
		},
		{
			description:     "docker build system error",
			localBuild:      latest.LocalBuild{UseDockerCLI: true},
			err:             errdefs.System(fmt.Errorf("something else")),
			expectedErr:     fmt.Errorf("something else"),
			expectedErrCode: proto.StatusCode_BUILD_DOCKER_SYSTEM_ERR,
		},
	}

	for _, test := range tests {
		testutil.Run(t, test.description, func(t *testutil.T) {
			t.NewTempDir().Touch("Dockerfile").Chdir()
			dockerfilePath, _ := filepath.Abs("Dockerfile")
			t.Override(&docker.EvalBuildArgsWithEnv, func(_ config.RunMode, _ string, _ string, args map[string]*string, _ map[string]*string, _ map[string]string) (map[string]*string, error) {
				return args, nil
			})
			t.Override(&docker.DefaultAuthHelper, stubAuth{})
			t.Override(&osCreateTemp, func(dir, pattern string) (*os.File, error) {
				tmp := t.TempFile("metadata*.json", []byte(metadata))
				os.Rename(tmp, "metadata.json")
				return os.Open("metadata.json")
			})
			t.Override(&config.GetConfigForCurrentKubectx, func(configFile string) (*config.ContextConfig, error) {
				return &config.ContextConfig{CacheTag: "cache", BuildXBuilder: "default"}, nil
			})
			var mockCmd *testutil.FakeCmd

			imageName := "tag"
			if test.imageName != "" {
				imageName = test.imageName
			}

			if test.err != nil {
				var pruneFlag string
				if test.cfg.Prune() {
					pruneFlag = " --force-rm"
				}
				mockCmd = testutil.CmdRunErr(
					"docker build . --file "+dockerfilePath+" -t "+imageName+pruneFlag,
					test.err,
				)
				t.Override(&util.DefaultExecCommand, mockCmd)
			}
			if test.wantDockerCLI {
				cmdLine := "docker build . --file " + dockerfilePath + " -t " + imageName
				if len(test.expectedCLIFlags) > 0 {
					cmdLine += " " + strings.Join(test.expectedCLIFlags, " ")
				}
				mockCmd = testutil.CmdRunEnv(cmdLine, test.expectedEnv)
				t.Override(&util.DefaultExecCommand, mockCmd)
			}
			t.Override(&util.OSEnviron, func() []string { return []string{"KEY=VALUE"} })

			builder := NewArtifactBuilder(fakeLocalDaemonWithExtraEnv(test.extraEnv, test.daemonless), test.cfg, test.localBuild.UseDockerCLI, test.localBuild.UseBuildkit, test.buildx, test.buildx && test.localBuild.Push != nil && *test.localBuild.Push, mockArtifactResolver{make(map[string]string)}, nil)

			artifact := &latest.Artifact{
				Workspace: ".",
				ArtifactType: latest.ArtifactType{
					DockerArtifact: &latest.DockerArtifact{
						DockerfilePath: "Dockerfile",
						CliFlags:       test.cliFlags,
					},
				},
			}
			if test.buildx {
				parts := strings.Split(imageName, ":")
				artifact.ImageName = parts[0]
				artifact.DockerArtifact.CacheFrom = []string{parts[0]}
			}

			digest, err := builder.Build(context.Background(), io.Discard, artifact, imageName, platform.Matcher{})
			t.CheckError(test.err != nil, err)
			t.CheckTrue(digest != "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855") // not empty string hash
			if mockCmd != nil {
				t.CheckDeepEqual(1, mockCmd.TimesCalled())
			}
			if test.err != nil && test.expectedErrCode != 0 {
				if ae, ok := err.(*sErrors.ErrDef); ok {
					t.CheckDeepEqual(test.expectedErrCode, ae.StatusCode(), protocmp.Transform())
					t.CheckErrorContains(test.expectedErr.Error(), ae)
				} else {
					t.Fatalf("expected to find an actionable error. not found")
				}
			}
		})
	}
}

func TestDockerCLICheckCacheFromArgs(t *testing.T) {
	tests := []struct {
		description       string
		artifact          *latest.Artifact
		tag               string
		expectedCacheFrom []string
	}{
		{
			description: "multiple cache-from images",
			artifact: &latest.Artifact{
				ImageName: "gcr.io/k8s-skaffold/test",
				ArtifactType: latest.ArtifactType{
					DockerArtifact: &latest.DockerArtifact{
						CacheFrom: []string{"from/image1", "from/image2"},
					},
				},
			},
			tag:               "tag",
			expectedCacheFrom: []string{"from/image1", "from/image2"},
		},
		{
			description: "cache-from self uses tagged image",
			artifact: &latest.Artifact{
				ImageName: "gcr.io/k8s-skaffold/test",
				ArtifactType: latest.ArtifactType{
					DockerArtifact: &latest.DockerArtifact{
						CacheFrom: []string{"gcr.io/k8s-skaffold/test"},
					},
				},
			},
			tag:               "gcr.io/k8s-skaffold/test:tagged",
			expectedCacheFrom: []string{"gcr.io/k8s-skaffold/test:tagged"},
		},
	}

	for _, test := range tests {
		testutil.Run(t, test.description, func(t *testutil.T) {
			t.NewTempDir().Touch("Dockerfile").Chdir()
			dockerfilePath, _ := filepath.Abs("Dockerfile")
			a := *test.artifact
			a.Workspace = "."
			a.DockerArtifact.DockerfilePath = dockerfilePath
			t.Override(&docker.DefaultAuthHelper, stubAuth{})
			t.Override(&docker.EvalBuildArgsWithEnv, func(_ config.RunMode, _ string, _ string, args map[string]*string, _ map[string]*string, _ map[string]string) (map[string]*string, error) {
				return args, nil
			})

			mockCmd := testutil.CmdRun(
				"docker build . --file " + dockerfilePath + " -t " + test.tag + " --cache-from " + strings.Join(test.expectedCacheFrom, " --cache-from "),
			)
			t.Override(&util.DefaultExecCommand, mockCmd)

			builder := NewArtifactBuilder(fakeLocalDaemonWithExtraEnv([]string{}, false), mockConfig{}, true, util.Ptr(false), false, false, mockArtifactResolver{make(map[string]string)}, nil)
			_, err := builder.Build(context.Background(), io.Discard, &a, test.tag, platform.Matcher{})
			t.CheckNoError(err)
		})
	}
}

func fakeLocalDaemonWithExtraEnv(extraEnv []string, daemonless bool) docker.LocalDaemon {
	return docker.NewLocalDaemon(&testutil.FakeAPIClient{ErrVersion: daemonless}, extraEnv, false, nil)
}

type mockArtifactResolver struct {
	m map[string]string
}

func (r mockArtifactResolver) GetImageTag(imageName string) (string, bool) {
	if r.m == nil {
		return "", false
	}
	val, found := r.m[imageName]
	return val, found
}

type stubAuth struct{}

func (t stubAuth) GetAuthConfig(context.Context, string) (registry.AuthConfig, error) {
	return registry.AuthConfig{}, nil
}

func (t stubAuth) GetAllAuthConfigs(context.Context) (map[string]registry.AuthConfig, error) {
	return nil, nil
}

type mockConfig struct {
	runMode config.RunMode
	prune   bool
}

func (m mockConfig) GetKubeContext() string {
	return ""
}

func (m mockConfig) GlobalConfig() string {
	return ""
}

func (m mockConfig) MinikubeProfile() string {
	return ""
}

func (m mockConfig) GetInsecureRegistries() map[string]bool {
	return map[string]bool{}
}

func (m mockConfig) Mode() config.RunMode {
	return m.runMode
}

func (m mockConfig) Prune() bool {
	return m.prune
}

func (m mockConfig) ContainerDebugging() bool {
	return false
}
